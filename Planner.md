# Overview

The planner is made of a trajectory generator, a trajectory evaluator, a state machine, and uses information encoded in the RNDF and MDF.

The RNDF (Road Network Data Format) and MDF (Mission Data Format) files contain information about the road network and the mission. The RNDF encodes the position of the lanes, stop signs, pedestrian crossings, intersections, speed limits, etc. It is generally generated by hand. The MDF encodes information about the mission, i.e. the set of way points to visit. These are legacy from the Darpa Grand Challenge and Darpa Urban Challenge.

The state machine contains states such as "driving", "approaching intersection", "in intersection", etc.

The planner starts by computing the route, i.e. the sequence of lanes to follow to accomplish the mission, which is a simple graph problem. It then generates the center line, which is the nominal trajectory that follows the center of those lanes. The trajectory generator generates a bunch of trajectories, that will more or less follow the center line. The trajectory evaluator will pick the best trajectory, i.e. the one that avoids collision with obstacles, remains withing the lane boundaries, and minimizes jerk.

The trajectory is a set of points in the plane, with desired velocity encoded. It also includes some precomputed geometric values (orientation, curvature, etc.) and a time at which the car should be at each point. The time information should probably be removed.

The trajectory is passed to a trajectory controller, which will compute the desired velocity and wheel angle to 1) go to the trajectory and 2) follow the trajectory. The output of the trajectory controller is passed to the actuator controller, which computes the desired throttle, brake, and steering torque required. Those are sent to the drive by wire box.

# Simulator

There is also a simulator, that can take the output of the trajectory controller, and generates data similar to what the car would produce: applanix messages, CAN messages, etc.

The simulator does not understand the output of the actuator controller. This is because 1) it is not clear how throttle, brake and steering torque modify the car's motion, and 2) it would take too much time to come up with a realistic model that would allow to test and tune the actuator controller in simulation and hope to be able to use the same parameters on the car directly.

The simulator is designed to support several cars at the same time, with fake perception, and extra avatars: pedestrians, hand controlled cars, etc. But this is work in progress. Most of the rest of the code though does not support multiple cars, and this may have to be changed at some point.

The simulator is designed to be ran as a monolithic entity or as a light weight node. As a light weight node, planning and control is done in a separate node. As a monolithic entity, everything runs in a single process. This is useful for debugging, as time can be controlled step by step, and the debugger can access the whole code.

## Running the simulator

```
# launch the core and load the parameters
roslaunch stdr_common junior2.launch

# use simulated time
rosparam set use_sim_time true

# run the simulator as a monolithic entity
rosparam set /simulator/monolithic true

# choose the planner
# it can be paw2 (the real planner, which is the default), or one of the fake planners
# (trajectory generators): fake_straight, fake_eight, fake_clothoid
rosparam set /simulator/planner_type fake_straight

# set the simulated vehicle model type
# currently only "simple" is supported
rosparam set /simulator/vehicle_model_type simple

# set the starting yaw angle (not required)
rosparam set /driving/simulator/vehicle_start_theta 0

# optionally set an offset for the fake planner
# if you want to test going toward the trajectory for instance
rosparam set /driving/fake_planner/y_offset 0
rosparam set /driving/fake_planner/theta_offset 0

# start the simulator
rosrun aw_simulator simulator
```

If you don't set the simulator to monolithic, then you also need to run

```
rosrun controller traj_controller_node
rosrun controller act_controller_node
```

# Visualizing with Rviz

In rviz, the trajectory can be viewed with the Trajectory2D display (from package carviz), on topic /driving/Trajectory2D.

# Code

The simulator can be found in package aw_simulator.

The planner code is found in stdr_planners/aw_road_planner.cpp which is a front end to a lot of code in aw_chsm_planning and all depended packages.

Package stdr_planners also contains the code for the fake planners.

Package controller contains the code for the trajectory controllers and actuators controllers.

The planners and controllers are defined as hierarchies of classes, so that several types of planners / controllers can be used, as decided by a ros parameter at run time. This is contrary to the ROS design philosophy, where the interface of a node is defined by its set of incoming and outgoing messages, instead of an API interface, but this is to allow running the simulation as a monolithic executable, which I found would be quite useful.

The constructors for the planners and controllers take a node handle as a parameter. This node handle is used to retrieve the parameters and create the subscriber and publisher. The intent is to have a node handle (or namespace) for each simulated vehicle. The rest of the code uses the /driving namespace for all parameters, publishers and subscribers.
